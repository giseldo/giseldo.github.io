<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1&nbsp; Introdução – Construindo Chatbots</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../sections/5_eliza-e-aiml-cap-eliza.html" rel="next">
<link href="../sections/3_resumo-resumo-unnumbered.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-d9ea66fcd6c317012447f26e9c021348.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../sections/4_introdu-o.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introdução</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Construindo Chatbots</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bem vindo</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sections/1_pref-cio-pref-cio-unnumbered.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefácio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sections/2_informa-es-informa-es-unnumbered.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Informações</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sections/3_resumo-resumo-unnumbered.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Resumo</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sections/4_introdu-o.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introdução</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sections/5_eliza-e-aiml-cap-eliza.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">ELIZA e AIML</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sections/6_processamento-de-linguagem-natural-pln-cap-pln.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Processamento de Linguagem Natural (PLN)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sections/7_modelos-de-linguagem-grande-llm-cap-llm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Modelos de Linguagem Grande (LLM)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sections/8_conclus-o-conclusao.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Conclusão</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sections/9_agradecimentos-agradecimentos-unnumbered.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Agradecimentos</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../sections/10_sobre-os-autores-sobre-os-autores-unnumbered.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sobre os autores</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#contexto" id="toc-contexto" class="nav-link active" data-scroll-target="#contexto"><span class="header-section-number">1.1</span> Contexto</a></li>
  <li><a href="#agentes" id="toc-agentes" class="nav-link" data-scroll-target="#agentes"><span class="header-section-number">1.2</span> Agentes</a></li>
  <li><a href="#fluxo-conversacional" id="toc-fluxo-conversacional" class="nav-link" data-scroll-target="#fluxo-conversacional"><span class="header-section-number">1.3</span> Fluxo Conversacional</a></li>
  <li><a href="#histórico" id="toc-histórico" class="nav-link" data-scroll-target="#histórico"><span class="header-section-number">1.4</span> Histórico</a></li>
  <li><a href="#abordagens" id="toc-abordagens" class="nav-link" data-scroll-target="#abordagens"><span class="header-section-number">1.5</span> Abordagens</a></li>
  <li><a href="#chatbot-pensa" id="toc-chatbot-pensa" class="nav-link" data-scroll-target="#chatbot-pensa"><span class="header-section-number">1.6</span> Chatbot pensa?</a></li>
  <li><a href="#exercícios" id="toc-exercícios" class="nav-link" data-scroll-target="#exercícios"><span class="header-section-number">1.7</span> Exercícios</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introdução</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="epigraph">
<p>“Podemos ver apenas uma curta distância à frente, mas pode-se ver muito que precisa ser feito.”</p>
<p>Alan Turing</p>
</div>
<div class="myboxobj">
<p>Objetivo Apresentar os conceitos fundamentais de chatbots, sua classificação, histórico e principais abordagens, preparando o leitor para compreender a evolução dessas tecnologias.</p>
</div>
<section id="contexto" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="contexto"><span class="header-section-number">1.1</span> Contexto</h2>
<p>Para uma parcela da população um chatbot, estilo ChatGPT, é ferramenta essencial para executar tarefas, redigir e-mails e traduzir textos. O que um dia causou espanto e admiração hoje se converteu em dependência. Neste contexto, um chatbot é um programa de computador que simula uma conversa humana, via texto ou áudio, oferecendo respostas diretas a perguntas e apoiando diversas atividades, desde conversas gerais até ações específicas, como abrir uma conta bancária ou agendar um voo para o show do seu cantor preferido.</p>
<p>Para entender como chegamos a esse ponto, vale recordar a trajetória do próprio conceito. Embora o programa ELIZA, criado por <span class="citation" data-cites="Weizenbaum1996">@Weizenbaum1996</span>, seja frequentemente citado como um dos primeiros exemplos de software conversacional, o termo “chatbot” ainda não era empregado à época. Sua origem remete a “chatterbot” — sinônimo de “chatbot” —, popularizado por Michael Mauldin em 1994 ao descrever seu programa JULIA <span class="citation" data-cites="Mauldin1994">[@Mauldin1994]</span>. Anos depois, outras publicações acadêmicas, como os anais da <em>Virtual Worlds and Simulation Conference</em> de 1998 <span class="citation" data-cites="Jacobstein1998">[@Jacobstein1998]</span>, contribuíram para consolidar os termos entre os pesquisadores.</p>
<p>O chatbot ELIZA representou um experimento marcante na interação entre humano e computador <span class="citation" data-cites="Weizenbaum1996">[@Weizenbaum1996]</span>. Seu roteiro (ou script) mais famoso, o DOCTOR, imitava rudimentarmente um psicoterapeuta, utilizando correspondência de padrões simples. Por exemplo, quando um usuário inseria a frase “<em>Estou triste</em>” no ELIZA, o programa respondia “<em>Por que você está triste hoje?</em>”, reformulando a entrada do usuário como uma pergunta. O funcionamento básico do sistema baseava-se em um conjunto restrito de regras e substituições, o que lhe permitia apenas uma compreensão superficial e limitada da linguagem humana.</p>
<p>O roteiro DOCTOR do ELIZA adequou-se bem a um tipo de diálogo mais simples, pois suas respostas dependiam de pouco conhecimento sobre o ambiente externo. As regras no roteiro permitiam que o programa respondesse ao usuário com outras perguntas ou simplesmente refletisse a afirmação original.</p>
<div class="mdframed">
<p><span class="smallcaps">NOTA</span></p>
<p>Uma descrição detalhada do funcionamento do ELIZA e o roteiro DOCTOR, com exemplos em Python, será apresentada no Capítulo&nbsp;<a href="5_eliza-e-aiml-cap-eliza.html" data-reference-type="ref" data-reference="cap:ELIZA">2</a>.</p>
</div>
<p>Outro chatbot famoso é o ChatGPT da OpenAI. Ele é um programa capaz de gerar texto muito semelhante ao criado por humanos. Ele utiliza redes neurais, com aprendizagem profunda, para gerar sentenças e parágrafos com base nas entradas e informações fornecidas. Entre suas capacidades, ele pode traduzir e resumir textos, responder a perguntas e explicar conceitos. Contudo, o ChatGPT não possui consciência nem a capacidade de compreender contexto ou emoções.</p>
<p>O chatGPT é um exemplo de Modelo de Linguagem Grande (em inglês Large Language Model - LLM), baseado na arquitetura <em>Transformers</em>, introduzida em 2017 <span class="citation" data-cites="vaswani2017attention">[@vaswani2017attention]</span>. Modelos deste tipo são treinados com terabytes de texto, utilizando mecanismos de autoatenção que avaliam a relevância de cada palavra em uma frase. Ao contrário das regras manuais do ELIZA, os LLMs extraem padrões linguísticos a partir da vasta quantidade de dados com que a rede neural foi treinada.</p>
<p>Esses dois chatbots, ELIZA e ChatGPT, são bons representantes do tipo de chatbot conversacional. Apesar de terem surgido com décadas de diferença — ELIZA em 1966 e ChatGPT em 2022 — e de diferirem bastante na forma como geram suas respostas, ambos compartilham semelhanças em seu objetivo: conversar sobre determinado assunto ou responder perguntas, mantendo o usuário em um diálogo fluido quando necessário. Chatbots com essas características podem ser agrupados, de acordo com o objetivo, como chatbots conversacionais e são utilizados para interagir sobre assuntos gerais.</p>
<p>Outro tipo de chatbot classificado em relação ao objetivo é o chatbot orientado a tarefas. Os chatbots orientados a tarefas executam ações específicas, como abrir uma conta bancária ou pedir uma pizza. Geralmente, as empresas disponibilizam chatbots orientados a tarefas para seus usuários, com regras de negócio embutidas na conversação e com fluxos bem definidos. Normalmente, não se espera pedir uma pizza e, no mesmo chatbot, discutir os estudos sobre Ética do filósofo Immanuel Kant (embora talvez haja quem queira).</p>
<p>Essas duas classificações, “conversacional” e “orientado a tarefas”, ainda não são suficientes para uma completa classificação. Existem outras classificações que serão discutidas em seções posteriores. Além disso, uma abordagem híbrida, unindo funções de chatbots do tipo “conversacional” e “orientado a tarefas” vem sendo utilizada para atender às necessidades dos usuários.</p>
<p>A popularidade dos chatbots tem crescido significativamente em diversos domínios de aplicação <span class="citation" data-cites="B2020 Klopfenstein2017 Sharma2020">[@B2020; @Klopfenstein2017; @Sharma2020]</span>. Essa tendência é corroborada pelo aumento do interesse de busca pelo termo “chatbots”, conforme análise de dados do Google Trends no período entre 2020 e 2025 (Figura&nbsp;<a href="#fig:trends" data-reference-type="ref" data-reference="fig:trends">1.1</a>). Nesta figura, os valores representam o interesse relativo de busca ao longo do tempo, onde 100 indica o pico de popularidade no período analisado e 0 (ou a ausência de dados) indica interesse mínimo ou dados insuficientes.</p>
<figure id="fig:trends" class="figure">
<p>
<img src="./fig/trends.png" style="width:90.0%" alt="image" class="figure-img"> <span id="fig:trends" data-label="fig:trends"></span>
</p>
<figcaption>
Figure 1: Evolução do interesse de busca pelo termo “chatbot” (Google Trends, 2020-2025).<br> Fonte: Google Trends acesso em 05/04/2025
</figcaption>
</figure>
</section>
<section id="agentes" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="agentes"><span class="header-section-number">1.2</span> Agentes</h2>
<p>Os termos “chatbots” e “agentes” são usadas indiscriminadamente, o que pode causar confusão. Vamos a uma definição mais precisa. Um chatbot é um programa computacional projetado para interagir com usuários por meio de linguagem natural. Por outro lado, o conceito de agente possui uma definição mais ampla. Um agente trata-se de uma entidade computacional que percebe seu ambiente por meio de sensores e atua sobre esse ambiente por meio de atuadores.</p>
<p>Nesse contexto, um chatbot (Figura&nbsp;<a href="#fig:chatbot" data-reference-type="ref" data-reference="fig:chatbot">1.3</a>) pode ser considerado uma instanciação específica de um agente - veja na Figura&nbsp;<a href="#fig:agente" data-reference-type="ref" data-reference="fig:agente">1.2</a> a arquitetura conceitual de alto nível para um agente - cujo propósito primário é a interação conversacional em linguagem natural.</p>
<figure id="fig:agente" class="figure">
<p>
<img src="./fig/original_agente.png" style="width:80.0%" alt="image" class="figure-img"> <span id="fig:agente" data-label="fig:agente"></span>
</p>
<figcaption>
Figure 2: Arquitetura conceitual de um agente.<br> Fonte: Adaptado de <span class="citation" data-cites="Russel2013">(Russel and Norving 2013)</span>
</figcaption>
</figure>
<figure id="fig:chatbot" class="figure">
<p>
<img src="./fig/chatbot.png" style="width:80.0%" alt="image" class="figure-img"> <span id="fig:chatbot" data-label="fig:chatbot"></span>
</p>
<figcaption>
Figure 3: Representação esquemática de um chatbot.
</figcaption>
</figure>
<p>Com o advento de modelos de linguagem, como os baseados na arquitetura <em>Generative Pretrained Transformer</em> (GPT), a exemplo do ChatGPT, observou-se uma recontextualização do termo “agente” no domínio dos sistemas conversacionais. Nessa abordagem mais recente, um sistema focado predominantemente na geração de texto conversacional tende a ser denominado “chatbot”. Em contraste, o termo “agente” é frequentemente reservado para sistemas que, além da capacidade conversacional, integram e utilizam ferramentas externas (por exemplo, acesso à Internet, execução de código e interação com APIs) para realizar tarefas complexas e interagir proativamente com o ambiente digital. Um sistema capaz de realizar uma compra online, processar um pagamento e confirmar um endereço de entrega por meio do navegador do usuário seria, portanto, classificado como um agente, diferentemente de chatbots mais simples como ELIZA, ou mesmo versões mais simples do chatGPT (GPT-2), cujo foco era estritamente o diálogo.</p>
</section>
<section id="fluxo-conversacional" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="fluxo-conversacional"><span class="header-section-number">1.3</span> Fluxo Conversacional</h2>
<p>Um chatbot responde a uma entrada do usuário. Porém, essa interação textual mediada por chatbots não se constitui em uma mera justaposição aleatória de turnos de conversação ou pares isolados de estímulo-resposta. Pelo contrário, espera-se que a conversação exiba coerência e mantenha relações lógicas e semânticas entre os turnos consecutivos. O estudo da estrutura e organização da conversa humana é abordado por disciplinas como a Análise da Conversação.</p>
<p>No contexto da análise da conversação em língua portuguesa, os trabalhos de Marcuschi <span class="citation" data-cites="Marchuschi1986">[@Marchuschi1986]</span> são relevantes ao investigar a organização dessa conversação. Marcuschi analisou a estrutura conversacional em termos de unidades coesas, como o “tópico conversacional”, que agrupa turnos relacionados a um mesmo assunto ou propósito interacional.</p>
<p>Conceitos oriundos da Análise da Conversação, como a gestão de tópicos, têm sido aplicados no desenvolvimento de chatbots para aprimorar sua capacidade de manter diálogos coerentes e contextualmente relevantes com usuários humanos <span class="citation" data-cites="Neves2005">[@Neves2005]</span>.</p>
<p>Na prática de desenvolvimento de sistemas conversacionais, a estrutura lógica e sequencial da interação é frequentemente modelada e referida como “fluxo de conversação” ou “fluxo de diálogo”. Contudo, é importante ressaltar que a implementação explícita de modelos sofisticados de gerenciamento de diálogo, inspirados na Análise da Conversação, não é uma característica universal de todos os chatbots, variando conforme a complexidade e o propósito do sistema.</p>
<p>Um exemplo esquemático de um fluxo conversacional é apresentado na Figura&nbsp;<a href="#fig:fluxo" data-reference-type="ref" data-reference="fig:fluxo">1.4</a>. Nesta figura, o fluxo de conversação inicia quando o usuário entra com o texto: I WANT PIZZA, o chatbot responde com uma pergunta: HI I AM THE PIZZA BOT. CAN I CONFIRM THIS DELIVERY TO YOUR HOUSE? O usuário então pode responder: YES, e o chatbot finaliza a conversa com: IT’S ON THE WAY. THANK YOU FOR CHOOSE OUR PRODUCT. Caso o usuário responda: NO, o chatbot responde com a pergunta original: HI I AM THE PIZZA BOT. CAN I CONFIRM THIS DELIVERY TO YOUR HOUSE? O fluxo de conversação continua até que o usuário responda com um “YES” para a pergunta inicial. Essa estrutura de perguntas e respostas é comum em chatbots orientados a tarefas, onde o objetivo é guiar o usuário por um processo específico, tal como fazer um pedido de pizza.</p>
<figure id="fig:fluxo" class="figure">
<p>
<img src="./fig/fluxo.png" style="width:90.0%" alt="image" class="figure-img"> <span id="fig:fluxo" data-label="fig:fluxo"></span>
</p>
<figcaption>
Figure 4: Exemplo esquemático de um fluxo conversacional em um chatbot.
</figcaption>
</figure>
<p>Um outro tipo de fluxo para um chatbot que vende roupas online está representado na Figura&nbsp;<a href="#fig:representacaodeumaarvore" data-reference-type="ref" data-reference="fig:representacaodeumaarvore">1.5</a>.</p>
<figure id="fig:representacaodeumaarvore" class="figure">
<p>
<img src="./fig/image14.png" style="width:70.0%" alt="image" class="figure-img"> <span id="fig:representacaodeumaarvore" data-label="fig:representacaodeumaarvore"></span>
</p>
<figcaption>
Figure 5: Representação de uma árvore de decisão para vender roupas online.<br> Retirado de <span class="citation" data-cites="Raj2019">(Raj 2019)</span>.
</figcaption>
</figure>
</section>
<section id="histórico" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="histórico"><span class="header-section-number">1.4</span> Histórico</h2>
<p>Um marco significativo na evolução dos chatbots depois do ELIZA foi o ALICE, que introduziu a Artificial Intelligence Markup Language (AIML), uma linguagem de marcação baseada em XML <span class="citation" data-cites="Wallace2000">[@Wallace2000]</span>. A AIML estabeleceu um paradigma para a construção de agentes conversacionais ao empregar algoritmos de correspondência de padrões. Essa abordagem utiliza modelos pré-definidos para mapear as entradas do usuário a respostas correspondentes, permitindo a definição modular de blocos de conhecimento <span class="citation" data-cites="Wallace2000">[@Wallace2000]</span>.</p>
<p>No contexto brasileiro, um dos primeiros chatbots documentados capaz de interagir em português, inspirado no modelo ELIZA, foi o Cybele <span class="citation" data-cites="primo2001chatterbot">[@primo2001chatterbot]</span>. Posteriormente, foi desenvolvido o Elecktra, também em língua portuguesa, com aplicação voltada para a educação a distância <span class="citation" data-cites="Leonhardt2003">[@Leonhardt2003]</span>. Em 2019, o processo de inscrição para o Exame Nacional do Ensino Médio (ENEM) foi disponibilizado por meio de uma interface conversacional baseada em chatbot (Figura&nbsp;<a href="#fig:enem" data-reference-type="ref" data-reference="fig:enem">1.6</a>).</p>
<figure id="fig:enem" class="figure">
<p>
<img src="./fig/enem.png" style="width:70.0%" alt="image" class="figure-img"> <span id="fig:enem" data-label="fig:enem"></span>
</p>
<figcaption>
Figure 6: Interface de chatbot para inscrição no ENEM 2019.
</figcaption>
</figure>
<p>O desenvolvimento de chatbots tem atraído investimentos de grandes corporações. Notavelmente, a IBM desenvolveu um sistema de resposta a perguntas em domínio aberto utilizando sua plataforma Watson <span class="citation" data-cites="Ferrucci2012">[@Ferrucci2012]</span>. Esse tipo de tarefa representa um desafio computacional e de inteligência artificial (IA) considerável. Em 2011, o sistema baseado em Watson demonstrou sua capacidade ao competir e vencer competidores humanos no programa de perguntas e respostas JEOPARDY! <span class="citation" data-cites="Ferrucci2012">[@Ferrucci2012]</span>.</p>
<p>Diversos outros chatbots foram desenvolvidos para atender a demandas específicas em variados domínios. Exemplos incluem: BUTI, um companheiro virtual com computação afetiva para auxiliar na manutenção da saúde cardiovascular <span class="citation" data-cites="Junior2008">[@Junior2008]</span>; EduBot, um agente conversacional projetado para a criação e desenvolvimento de ontologias com lógica de descrição <span class="citation" data-cites="Lima2017">[@Lima2017]</span>; PMKLE, um ambiente inteligente de aprendizado focado na educação em gerenciamento de projetos <span class="citation" data-cites="Torreao2005">[@Torreao2005]</span>; RENAN, um sistema de diálogo inteligente fundamentado em lógica de descrição <span class="citation" data-cites="AZEVEDO2015">[@AZEVEDO2015]</span>; e MOrFEu, voltado para a mediação de atividades cooperativas em ambientes inteligentes na Web <span class="citation" data-cites="Bada2012">[@Bada2012]</span>.</p>
<p>Entre os chatbots baseados em LLMs de destaque atualmente estão o Qwen <a href="https://chat.qwen.ai/" class="uri">https://chat.qwen.ai/</a>, desenvolvido pela Alibaba, que se destaca por sua eficiência e suporte multilíngue; o DeepSeek <a href="https://chat.deepseek.com/" class="uri">https://chat.deepseek.com/</a>, de código aberto voltado para pesquisa e aplicações empresariais com foco em precisão e escalabilidade; o Maritaca <a href="https://chat.maritaca.ai/" class="uri">https://chat.maritaca.ai/</a>, modelo brasileiro otimizado para o português; o Gemini <a href="https://gemini.google.com/" class="uri">https://gemini.google.com/</a>, da Google, que integra capacidades multimodais e forte desempenho em tarefas diversas; o Mistral<a href="https://chat.mistral.ai/" class="uri">https://chat.mistral.ai/</a>, da Mistral AI, que utiliza arquitetura de mistura de especialistas para maior eficiência; o Llama <a href="https://www.meta.ai/" class="uri">https://www.meta.ai/</a>, da Meta, reconhecido por ser código aberto e ampla adoção na comunidade; o Claude <a href="https://claude.ai/" class="uri">https://claude.ai/</a>, da Anthropic, projetado com ênfase em segurança e alinhamento ético, que vem ganhando adeptos para tarefas e codificação; e o Nemotron <a href="https://build.nvidia.com/models" class="uri">https://build.nvidia.com/models</a>, da NVIDIA, que oferece modelos de linguagem otimizados para execução em GPUs e aplicações empresariais de alto desempenho. E o Groq <a href="https://grok.com/" class="uri">https://grok.com/</a> da xAI.</p>
</section>
<section id="abordagens" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="abordagens"><span class="header-section-number">1.5</span> Abordagens</h2>
<p>Desde o pioneirismo do ELIZA, múltiplas abordagens e técnicas foram exploradas para o desenvolvimento de chatbots. Entre as mais relevantes, destacam-se: AIML com correspondência de padrões (pattern matching), análise sintática (Parsing), modelos de cadeia de Markov (Markov Chain Models), uso de ontologias, redes neurais recorrentes (RNNs), redes de memória de longo prazo (LSTMs), modelos neurais sequência-a-sequência (Sequence-to-Sequence), aprendizado adversarial para geração de diálogo, além de abordagens baseadas em recuperação (Retrieval-Based) e generativas (Generative-Based) <span class="citation" data-cites="borah2018survey Ramesh2019 Shaikh2016 Abdul-Kader2015 Li2018">[@borah2018survey; @Ramesh2019; @Shaikh2016; @Abdul-Kader2015; @Li2018]</span>, entre outras.</p>
<p>A seguir, uma lista resumida das tecnologias e marcos da criação dos chatbots:</p>
<ul>
<li><p>ELIZA: o primeiro chatbot, que utilizava correspondência de padrões simples para simular um psicoterapeuta. Foi um marco na história dos chatbots e influenciou o desenvolvimento de sistemas conversacionais subsequentes <span class="citation" data-cites="Weizenbaum1996">[@Weizenbaum1996]</span>.</p></li>
<li><p>AIML: Artificial Intelligence Markup Language, uma linguagem de marcação baseada em XML que deu origem ao ALICE <span class="citation" data-cites="Wallace2000">[@Wallace2000]</span>. Essa linguagem de marcação permite a definição de regras de correspondência de padrões (pattern matching) para mapear entradas do usuário a respostas predefinidas.</p></li>
<li><p>Transformers: arquitetura de rede neural baseada em atenção, que revolucionou o processamento de linguagem natural (NLP) <span class="citation" data-cites="vaswani2017attention">[@vaswani2017attention]</span>. Modelos como BERT e GPT são exemplos de arquiteturas baseadas em <em>Transformer</em> que têm sido amplamente utilizadas em chatbots modernos.</p></li>
</ul>
<p>Além disso, diversos frameworks têm sido desenvolvidos para facilitar a criação desses agentes complexos, como CrewAI <span class="citation" data-cites="crewai2025">[@crewai2025]</span> e Mangaba.AI <span class="citation" data-cites="mangabaAI2025">[@mangabaAI2025]</span> e plataformas diversas como Hugging Face (e.g., <em>Transformers Agents</em>), que fornecem abstrações e ferramentas em Python para orquestrar múltiplos componentes e o uso de ferramentas externas.</p>
</section>
<section id="chatbot-pensa" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="chatbot-pensa"><span class="header-section-number">1.6</span> Chatbot pensa?</h2>
<p>Apesar do progresso recente de chatbots, o mecanismo fundamental da inteligência em nível humano, frequentemente refletido na comunicação, ainda não está totalmente esclarecido <span class="citation" data-cites="Shum2018">[@Shum2018]</span>. Para avançar na solução desses desafios, serão necessários progressos em diversas áreas da IA cognitiva, tais como: modelagem empática de conversas, modelagem de conhecimento e memória, inteligência de máquina interpretável e controlável, e calibração de recompensas emocionais <span class="citation" data-cites="Shum2018">[@Shum2018]</span>.</p>
<p>Uma das dificuldades na construção de chatbots do tipo orientado a tarefas - a exemplo do Artificial Intelligence Markup Language (AIML) usado no ALICE - reside em gerenciar a complexidade das estruturas condicionais (“se-então”) que definem o fluxo do diálogo <span class="citation" data-cites="Raj2019">[@Raj2019]</span>. Quanto maior o número de decisões a serem tomadas, mais complexas tendem a ser essas estruturas condicionais. Contudo, elas são essenciais para codificar fluxos de conversação complexos. Se a tarefa que o chatbot visa simular é inerentemente complexa e envolve múltiplas condições, o código precisará refletir essa complexidade. Para facilitar a visualização desses fluxos, uma solução eficaz é a utilização de fluxogramas. Embora simples de criar e entender, os fluxogramas constituem uma ferramenta visual de representação para este problema.</p>
<div class="mdframed">
<p><span class="smallcaps">NOTA</span></p>
<p>Uma explicação detalhada do AIML será apresentada no Capítulo&nbsp;<a href="5_eliza-e-aiml-cap-eliza.html" data-reference-type="ref" data-reference="cap:ELIZA">2</a>.</p>
</div>
<p>Os chatbots baseados em AIML apresentam desvantagens específicas. Por exemplo, o conhecimento é representado como instâncias de arquivos AIML. Se esse conhecimento for criado com base em dados coletados da Internet, ele não será atualizado automaticamente, exigindo atualizações periódicas manuais <span class="citation" data-cites="Madhumitha2015">[@Madhumitha2015]</span>. No entanto, já existem abordagens para mitigar essa limitação, permitindo carregar conteúdo AIML a partir de fontes como arquivos XML <span class="citation" data-cites="Macedo2014">[@Macedo2014]</span>, um corpus textual <span class="citation" data-cites="DeGasperis2013">[@DeGasperis2013]</span> ou dados do Twitter <span class="citation" data-cites="Yamaguchi2018">[@Yamaguchi2018]</span>. Além de abordagens no-code que geram o AIML a partir de fluxogramas <span class="citation" data-cites="neo2023BPMN">[@neo2023BPMN]</span>.</p>
<p>Outra desvantagem do AIML, a exemplo do Eliza, reside na relativa complexidade de seus padrões de correspondência (patterns). Além disso, a manutenção do sistema pode ser árdua, pois, embora a inserção de conteúdo (categorias) seja conceitualmente simples, grandes volumes de informação frequentemente precisam ser adicionados manualmente <span class="citation" data-cites="Madhumitha2015">[@Madhumitha2015]</span>.</p>
<p>Especificamente no caso do AIML, a construção e a visualização de fluxos de diálogo complexos enfrentam dificuldades adicionais. Devido ao seu formato baseado em texto, muitas vezes é difícil perceber claramente como as diferentes categorias (unidades de conhecimento e resposta) se interligam para formar a estrutura da conversação.</p>
<p>O interesse pelos chatbots continua crescendo. No entanto, eles podem ser complicados para se construir e os usuários nem sempre têm experiência suficiente para configurá-los. Alguns usuários não têm necessariamente habilidades de programação ou de TI avançadas. Para que eles possam criar e personalizar os chatbots, é importante que a autoria seja fácil de usar e intuitiva. Ela não deve exigir conhecimento de linguagens de computador que sejam difíceis de entender para o público em geral. Para resolver esses problemas, várias ferramentas de autoria já foram propostas e podem ser utilizadas por usuários sem o uso de código, ferramentas no-code <span class="citation" data-cites="Neo2023Chatcreator">[@Neo2023Chatcreator]</span>.</p>
<p>Mesmo um chatbot baseado em LLM também não “pensa” no sentido cognitivo humano, mas opera a partir de um mecanismo estatístico de predição de tokens condicionado a um contexto. Sua forma de funcionamento é sustentada por arquiteturas neurais profundas, treinadas sobre grandes volumes de dados textuais, que capturam regularidades linguísticas, semânticas e pragmáticas. Assim, a resposta gerada resulta da estimativa da sequência de palavras mais provável dado um histórico de entrada, e não de um processo deliberativo consciente.</p>
<p>A aparente coerência e racionalidade observadas nas respostas decorrem da capacidade do modelo em representar padrões complexos da linguagem natural em espaços vetoriais de alta dimensão. Esses modelos internalizam relações sintáticas, semânticas e discursivas, permitindo generalização para contextos não vistos durante o treinamento. Dessa forma, o chatbot consegue simular comportamentos como argumentação, explicação e síntese, ainda que tais comportamentos sejam emergentes do ajuste estatístico e não de compreensão genuína.</p>
<p>A justificativa para esse modo de “pensar” reside na eficácia prática do paradigma. Ao invés de regras explícitas ou sistemas simbólicos rígidos, os LLMs oferecem flexibilidade, escalabilidade e adaptação a múltiplos domínios, o que os torna adequados para tarefas complexas de interação homem-máquina. A combinação de aprendizado profundo, atenção contextual e grandes corpora textuais permite ao chatbot responder de forma contextualizada, mantendo consistência local e global no discurso.</p>
<p>Por fim, é fundamental reconhecer as limitações inerentes a esse modelo de funcionamento. A ausência de intencionalidade, consciência e compreensão semântica profunda implica que o chatbot pode produzir respostas plausíveis, porém factualmente incorretas ou logicamente inconsistentes. Assim, a forma de “pensar” de um chatbot baseado em LLM deve ser entendida como um mecanismo probabilístico avançado de geração de linguagem, útil e poderoso, mas distinto do raciocínio humano.</p>
</section>
<section id="exercícios" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="exercícios"><span class="header-section-number">1.7</span> Exercícios</h2>
<ol type="1">
<li><p><strong>Qual é o objetivo principal de um chatbot?</strong></p>
<ol type="1">
<li><p>Substituir completamente os seres humanos no atendimento ao cliente.</p></li>
<li><p>Simular uma conversa humana para resolver problemas ou fornecer informações.</p></li>
<li><p>Gerar textos literários complexos.</p></li>
<li><p>Armazenar grandes quantidades de dados em tempo real.</p></li>
</ol></li>
<li><p><strong>Qual das seguintes opções descreve corretamente um benefício dos chatbots?</strong></p>
<ol type="1">
<li><p>Eles nunca precisam ser atualizados.</p></li>
<li><p>Eles podem operar 24 horas por dia, 7 dias por semana, sem intervenção humana.</p></li>
<li><p>Eles sempre tomam decisões melhores do que humanos.</p></li>
<li><p>Eles substituem completamente a necessidade de suporte técnico.</p></li>
</ol></li>
<li><p><strong>Qual das opções a seguir é uma técnica comum usada por chatbots para entender o que o usuário está perguntando?</strong></p>
<ol type="1">
<li><p>Mineração de Dados</p></li>
<li><p>Tokenização</p></li>
<li><p>Compressão de Dados</p></li>
<li><p>Balanceamento de Carga</p></li>
</ol></li>
<li><p><strong>Qual é o papel dos embeddings de palavras em chatbots?</strong></p>
<ol type="1">
<li><p>Converter palavras em vetores numéricos que capturam o significado semântico.</p></li>
<li><p>Armazenar grandes quantidades de dados de conversação.</p></li>
<li><p>Executar algoritmos de compressão de texto.</p></li>
<li><p>Facilitar a tradução de texto entre diferentes idiomas.</p></li>
</ol></li>
<li><p><strong>Qual é a principal limitação dos chatbots baseados em regras?</strong></p>
<ol type="1">
<li><p>Eles não conseguem operar em tempo real.</p></li>
<li><p>Eles exigem grandes quantidades de dados para funcionar.</p></li>
<li><p>Eles só podem responder a consultas específicas para as quais foram</p></li>
<li><p>programados.</p></li>
<li><p>Eles são incapazes de realizar tarefas repetitivas.</p></li>
</ol></li>
</ol>


</section>

</main> <!-- /main -->
﻿<script>
(function () {
  function isTypingTarget(el) {
    if (!el) return false;
    var tag = el.tagName ? el.tagName.toLowerCase() : '';
    return tag === 'input' || tag === 'textarea' || tag === 'select' || el.isContentEditable;
  }

  function findLink(rel, fallbackSelector) {
    var byRel = document.querySelector('a[rel="' + rel + '"]');
    if (byRel) return byRel;
    return document.querySelector(fallbackSelector);
  }

  document.addEventListener('keydown', function (e) {
    if (e.defaultPrevented) return;
    if (isTypingTarget(e.target)) return;

    if (e.key === 'ArrowRight') {
      var nextLink = findLink('next', '.nav-page-next a');
      if (nextLink && nextLink.href) {
        window.location.href = nextLink.href;
      }
    } else if (e.key === 'ArrowLeft') {
      var prevLink = findLink('prev', '.nav-page-previous a');
      if (prevLink && prevLink.href) {
        window.location.href = prevLink.href;
      }
    }
  });
})();
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/giseldo\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../sections/3_resumo-resumo-unnumbered.html" class="pagination-link" aria-label="Resumo">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Resumo</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../sections/5_eliza-e-aiml-cap-eliza.html" class="pagination-link" aria-label="ELIZA e AIML">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">ELIZA e AIML</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Processamento de Linguagem Natural foi escrito por Giseldo Neo e Alana Neo.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Este html foi gerado com o <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>