<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pages on IA com GN</title>
    <link>http://localhost:1313/page/</link>
    <description>Recent content in Pages on IA com GN</description>
    <generator>Hugo</generator>
    <language>br</language>
    <managingEditor>giseldo@gmail.com (Giseldo Neo)</managingEditor>
    <webMaster>giseldo@gmail.com (Giseldo Neo)</webMaster>
    <atom:link href="http://localhost:1313/page/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Livros</title>
      <link>http://localhost:1313/page/livros/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>giseldo@gmail.com (Giseldo Neo)</author>
      <guid>http://localhost:1313/page/livros/</guid>
      <description>&lt;h2 id=&#34;chatbot-book&#34;&gt;Chatbot Book&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/capa.png&#34; alt=&#34;Chatbot Book&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/capa.png&#34; alt=&#34;Chatbot Book download&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;regressão-de-linear-com-aprendizagem-de-máquina-com-python&#34;&gt;Regressão de Linear com Aprendizagem de Máquina com Python&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.amazon.com.br/gp/product/B0DCT4M7GH&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Adquirir e-pub na Amazon&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://loja.uiclap.com/titulo/ua63343/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Adquirir livro físico na UICLAP&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;splitbox&#34;&gt;&lt;div class=&#34;left&#34;&gt;&#xD;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/livro/regressao.png&#34; alt=&#34;Regressão Linear&#34;&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;right&#34;&gt;&#xD;&#xA;&#xA;&lt;p&gt;Este livro fornece uma visão inicial e objetiva sobre a teoria e&#xA;a aplicação prática da regressão linear no contexto do aprendizado de máquina com python.&#xA;Ele é adequado para iniciantes que estão começando sua jornada no aprendizado de máquina&#xA;e da regressão linear, mas que já conhecem o básico da linguagem python.&#xA;Ao longo dos capítulos, apresentamos os conceitos e suposições da regressão até as&#xA;aplicações e diagnósticos de modelos, passando por estudos de caso e o uso de bibliotecas&#xA;de software utilizadas como Python e Scikit-learn. Os exercícios ao&#xA;final de cada capítulo são elaborados para reforçar este aprendizado.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Pesquisas</title>
      <link>http://localhost:1313/page/pesquisas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>giseldo@gmail.com (Giseldo Neo)</author>
      <guid>http://localhost:1313/page/pesquisas/</guid>
      <description>&lt;p&gt;Para mais informações sobre artigos publicados acesse o &lt;a href=&#34;https://www.researchgate.net/profile/Giseldo-Neo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;research gate&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Nosso grupo de pesquisa é o &lt;a href=&#34;https://sites.google.com/view/grupogci&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GCI - Grupo de Pesquisa em Gestão do Conhecimento e da Inovação pesquisa&lt;/a&gt;. Acesse o &lt;a href=&#34;https://sites.google.com/view/grupogci&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;site&lt;/a&gt; instituicional do grupo  para mais informações dos participantes e dos artigos públicados pelo grupo.&lt;/p&gt;&#xA;&lt;h2 id=&#34;áreas-de-interesse&#34;&gt;Áreas de Interesse&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Inteligência Artificial&lt;/li&gt;&#xA;&lt;li&gt;Aprendizagem de máquina&lt;/li&gt;&#xA;&lt;li&gt;Processamento de linguagem natural&lt;/li&gt;&#xA;&lt;li&gt;Chatbots&lt;/li&gt;&#xA;&lt;li&gt;Engenharia de Software&lt;/li&gt;&#xA;&lt;li&gt;Informática para educação&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;materiais-relacionados-a-alguns-dos-nossos-artigos-publicados&#34;&gt;Materiais relacionados a alguns dos nossos Artigos Publicados&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;NeoAVA - Um ambiente virtual de aprendizagem&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.researchgate.net/publication/385778737_NeoAVA_A_virtual_learning_environment_for_Self-Regulated_Learning_to_be_used_by_students_and_teachers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slide&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;NeoDataset&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.researchgate.net/publication/385778629_NeoDataset_Um_conjunto_de_dados_com_User_Stories_e_Story_Points&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slide&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;AQG (Answer Question Generator)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.researchgate.net/publication/385778557_Revisao_sobre_a_Geracao_Automatica_de_Questoes_na_Educacao_Tecnicas_Conjuntos_de_Dados_e_Metricas_de_Avaliacao&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slide&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Autorregulação&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.researchgate.net/publication/385778670_Modelagem_de_Autorregulacao_da_Aprendizagem_no_Ensino_Superior_Uma_Ferramenta_para_Automatizar_Levantamento_de_Perfis_e_Recomendacoes_Personalizadas&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slide&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Produtos</title>
      <link>http://localhost:1313/page/produtos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>giseldo@gmail.com (Giseldo Neo)</author>
      <guid>http://localhost:1313/page/produtos/</guid>
      <description>&lt;h2 id=&#34;neochatbots---chatbots-com-rag&#34;&gt;NeoChatbots - Chatbots com RAG&lt;/h2&gt;&#xA;&lt;p&gt;Chatbots com inteligência artificial&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Um chatbot que conversa sobre o manual do aluno do IFAL&lt;/li&gt;&#xA;&lt;li&gt;Um chatbot que conversa sobre o regimento do IFAL&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://giseldo.github.io/ifal/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NeoChatbots&lt;/a&gt;&lt;/p&gt;&#xA;&#xD;&#xA;&lt;link rel=&#34;stylesheet&#34; href=&#34;http://localhost:1313/css/hugo-easy-gallery.css&#34; /&gt;&#xD;&#xA;&lt;div class=&#34;box&#34; style=&#34;max-width:50%&#34;&gt;&#xD;&#xA;  &lt;figure  itemprop=&#34;associatedMedia&#34; itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;&#xD;&#xA;    &lt;div class=&#34;img&#34;&gt;&#xD;&#xA;      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://localhost:1313/images/pages/chatbots.png&#34; alt=&#34;/images/pages/chatbots.png&#34;/&gt;&#xD;&#xA;    &lt;/div&gt;&#xD;&#xA;    &lt;a href=&#34;http://localhost:1313/images/pages/chatbots.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;&#xD;&#xA;  &lt;/figure&gt;&#xD;&#xA;&lt;/div&gt;&#xD;&#xA;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;neostudy---um-gerador-de-plano-de-estudo-com-ia&#34;&gt;NeoStudy - Um Gerador de Plano de estudo com IA&lt;/h2&gt;&#xA;&lt;p&gt;Um gerador de plano de estudo personalizado com inteligência artificial&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://giseldo.github.io/study/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Study Plan&lt;/a&gt;&lt;/p&gt;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;div class=&#34;box&#34; style=&#34;max-width:50%&#34;&gt;&#xD;&#xA;  &lt;figure  itemprop=&#34;associatedMedia&#34; itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;&#xD;&#xA;    &lt;div class=&#34;img&#34;&gt;&#xD;&#xA;      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://localhost:1313/images/pages/planoestudo.png&#34; alt=&#34;/images/pages/planoestudo.png&#34;/&gt;&#xD;&#xA;    &lt;/div&gt;&#xD;&#xA;    &lt;a href=&#34;http://localhost:1313/images/pages/planoestudo.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;&#xD;&#xA;  &lt;/figure&gt;&#xD;&#xA;&lt;/div&gt;&#xD;&#xA;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;neocalendar---calendário-de-eventos-científicos&#34;&gt;NeoCalendar - Calendário de eventos científicos&lt;/h2&gt;&#xA;&lt;p&gt;Calendário de eventos científicos em ciência da computação&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://giseldo-eventos-v2.hf.space&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Calendário de eventos&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Podcast</title>
      <link>http://localhost:1313/page/podcast/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>giseldo@gmail.com (Giseldo Neo)</author>
      <guid>http://localhost:1313/page/podcast/</guid>
      <description>&lt;h2 id=&#34;gci-podcast&#34;&gt;GCI Podcast&lt;/h2&gt;&#xA;&lt;p&gt;No nosso podcast no spotify discutimos os principais achados e contribuições de nossas pesquisas. Queremos democratizar a ciência. Utilizamos uma linguagem acessível e explicamos nossas pesquisas.&#xA;&lt;a href=&#34;https://open.spotify.com/show/5OpCsJixh1o4gjSi5srRdS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Link do GCI Research Pocast no Spotify&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sobre</title>
      <link>http://localhost:1313/page/sobre/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>giseldo@gmail.com (Giseldo Neo)</author>
      <guid>http://localhost:1313/page/sobre/</guid>
      <description>&lt;h1 id=&#34;equipe&#34;&gt;Equipe&lt;/h1&gt;&#xA;&lt;h2 id=&#34;giseldo-neo&#34;&gt;Giseldo Neo&lt;/h2&gt;&#xA;&lt;p&gt;E-mail para contato: &lt;a href=&#34;mailto:giseldo@gmail.com&#34;&gt;giseldo@gmail.com&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;div class=&#34;splitbox&#34;&gt;&lt;div class=&#34;left&#34;&gt;&#xD;&#xA;&#xA;&#xD;&#xA;&lt;link rel=&#34;stylesheet&#34; href=&#34;http://localhost:1313/css/hugo-easy-gallery.css&#34; /&gt;&#xD;&#xA;&lt;div class=&#34;box&#34; style=&#34;max-width:50%&#34;&gt;&#xD;&#xA;  &lt;figure  itemprop=&#34;associatedMedia&#34; itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;&#xD;&#xA;    &lt;div class=&#34;img&#34;&gt;&#xD;&#xA;      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;http://localhost:1313/images/pages/giseldo.jpg&#34; alt=&#34;/images/pages/giseldo.jpg&#34;/&gt;&#xD;&#xA;    &lt;/div&gt;&#xD;&#xA;    &lt;a href=&#34;http://localhost:1313/images/pages/giseldo.jpg&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;&#xD;&#xA;  &lt;/figure&gt;&#xD;&#xA;&lt;/div&gt;&#xD;&#xA;&#xA;&lt;/div&gt;&lt;div class=&#34;right&#34;&gt;&#xD;&#xA;&#xA;Giseldo Neo é  pesquisador e Professor de Informática no Instituto Federal de Alagoas (IFAL). Doutorando em Ciência da Computação (UFCG), Mestre em Modelagem Computacional do Conhecimento (UFAL), Mestre em Administração e Contabilidade (FUCAPE). Possui MBA em Gestão e Estratégia Empresarial (ESTACIO), Especialização em Arquitetura e Engenharia de Software (ESTÁCIO), MBA em Gestão de Projetos (UNINTER). Graduação em Análise e Desenvolvimento de Sistemas (ESTÁCIO), Graduação em Processos Gerenciais (UNINTER) e Técnico de Informática pela ETF-SE (Escola técnica federal de sergipe).&#xA;&lt;/div&gt;&lt;div style=&#34;clear:both&#34;&gt;&lt;/div&gt;&lt;/div&gt;&#xD;&#xA;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/page/jogos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>giseldo@gmail.com (Giseldo Neo)</author>
      <guid>http://localhost:1313/page/jogos/</guid>
      <description>&lt;!DOCTYPE html&gt;&#xD;&#xA;&lt;html&gt;&#xD;&#xA;&lt;head&gt;&#xD;&#xA;  &lt;title&gt;Dinossauro Runner&lt;/title&gt;&#xD;&#xA;  &lt;style&gt;&#xD;&#xA;    /* Estilos do jogo */&#xD;&#xA;    canvas {&#xD;&#xA;      border: 1px solid black;&#xD;&#xA;    }&#xD;&#xA;    body {&#xD;&#xA;      display: flex;&#xD;&#xA;      flex-direction: column;&#xD;&#xA;      align-items: center;&#xD;&#xA;      font-family: Arial, sans-serif;&#xD;&#xA;    }&#xD;&#xA;    .controles {&#xD;&#xA;      margin-top: 10px;&#xD;&#xA;    }&#xD;&#xA;  &lt;/style&gt;&#xD;&#xA;&lt;/head&gt;&#xD;&#xA;&lt;body&gt;&#xD;&#xA;  &lt;canvas id=&#34;canvas&#34; width=&#34;800&#34; height=&#34;400&#34;&gt;&lt;/canvas&gt;&#xD;&#xA;  &lt;div class=&#34;controles&#34;&gt;Pressione ESPAÇO para pular&lt;/div&gt;&#xD;&#xA;  &lt;div class=&#34;controles&#34;&gt;&lt;small&gt;By Giseldo Neo at giseldo@gmail.com&lt;/small&gt;&lt;/div&gt;&#xD;&#xA;  &lt;script&gt;&#xD;&#xA;    &#xD;&#xA;    let canvas = document.getElementById(&#39;canvas&#39;);&#xD;&#xA;    let ctx = canvas.getContext(&#39;2d&#39;);&#xD;&#xA;    let dino = { x: 50, y: 200, largura: 50, altura: 50, velocidadeY: 0 };&#xD;&#xA;    let obstaculos = [];&#xD;&#xA;    let placar = 0;&#xD;&#xA;    let gravidade = 0.5;&#xD;&#xA;    let pulo = -10;&#xD;&#xA;    let estaNoChao = true;&#xD;&#xA;    let velocidadeJogo = 5;&#xD;&#xA;    let gameOver = false;&#xD;&#xA;&#xD;&#xA;    // Adicionar som para quando passar pelo obstáculo&#xD;&#xA;    let somPonto = new Audio(&#39;page/ponto.mp3&#39;);&#xD;&#xA;    // Adicionar som para game over&#xD;&#xA;    let somGameOver = new Audio(&#39;page/gameover.mp3&#39;);&#xD;&#xA;&#xD;&#xA;    // Variável para controlar a animação das pernas&#xD;&#xA;    let passo = 0;&#xD;&#xA;&#xD;&#xA;    // Hi-Score&#xD;&#xA;    let hiScore = 0;&#xD;&#xA;&#xD;&#xA;    // Montanhas&#xD;&#xA;    const montanha1 = { x: 0, y: 200, largura: 200, altura: 50, cor: &#39;#D2B48C&#39;, velocidade: 0.2 };&#xD;&#xA;    const montanha2 = { x: 400, y: 220, largura: 300, altura: 30, cor: &#39;#DEB887&#39;, velocidade: 0.1 };&#xD;&#xA;&#xD;&#xA;    // Nuvens&#xD;&#xA;    const nuvens = [&#xD;&#xA;      { x: 100, y: 50, largura: 80, altura: 30, velocidade: 0.05 },&#xD;&#xA;      { x: 300, y: 80, largura: 100, altura: 40, velocidade: 0.03 },&#xD;&#xA;      { x: 600, y: 60, largura: 120, altura: 50, velocidade: 0.07 }&#xD;&#xA;    ];&#xD;&#xA;    &#xD;&#xA;    // Tipos de obstáculos&#xD;&#xA;    const TIPOS_OBSTACULOS = [&#xD;&#xA;      { largura: 30, altura: 30, cor: &#39;red&#39;, y: 220 },           // Pequeno&#xD;&#xA;      { largura: 30, altura: 60, cor: &#39;darkred&#39;, y: 190 },       // Alto&#xD;&#xA;      { largura: 60, altura: 30, cor: &#39;brown&#39;, y: 220 },         // Largo&#xD;&#xA;      { largura: 40, altura: 40, cor: &#39;orange&#39;, y: 210 }         // Médio&#xD;&#xA;    ];&#xD;&#xA;&#xD;&#xA;    // Função para desenhar o cenário&#xD;&#xA;    function desenharCenario() {&#xD;&#xA;      // Desenhar céu&#xD;&#xA;      ctx.fillStyle = &#39;#87CEEB&#39;;&#xD;&#xA;      ctx.fillRect(0, 0, canvas.width, 250);&#xD;&#xA;&#xD;&#xA;      // Desenhar nuvens&#xD;&#xA;      desenharNuvens();&#xD;&#xA;&#xD;&#xA;      // Desenhar montanhas triangulares&#xD;&#xA;      desenharMontanhaTriangular(montanha1);&#xD;&#xA;      desenharMontanhaTriangular(montanha2);&#xD;&#xA;&#xD;&#xA;      // Desenhar chão&#xD;&#xA;      ctx.fillStyle = &#39;#aaa&#39;;&#xD;&#xA;      ctx.fillRect(0, 250, canvas.width, 2);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    function desenharMontanhaTriangular(montanha) {&#xD;&#xA;      ctx.fillStyle = montanha.cor;&#xD;&#xA;      ctx.beginPath();&#xD;&#xA;      ctx.moveTo(montanha.x, 250); // Ponto base esquerdo&#xD;&#xA;      ctx.lineTo(montanha.x + montanha.largura / 2, 250 - montanha.altura); // Ponto do pico&#xD;&#xA;      ctx.lineTo(montanha.x + montanha.largura, 250); // Ponto base direito&#xD;&#xA;      ctx.closePath();&#xD;&#xA;      ctx.fill();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    function desenharNuvens() {&#xD;&#xA;      ctx.fillStyle = &#39;white&#39;;&#xD;&#xA;      for (let i = 0; i &lt; nuvens.length; i++) {&#xD;&#xA;        const nuvem = nuvens[i];&#xD;&#xA;        ctx.fillRect(nuvem.x, nuvem.y, nuvem.largura, nuvem.altura);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    function desenharDino() {&#xD;&#xA;      // Desenhar corpo do gato&#xD;&#xA;      ctx.fillStyle = &#39;gray&#39;;&#xD;&#xA;      ctx.fillRect(dino.x, dino.y, dino.largura, dino.altura - 10);&#xD;&#xA;&#xD;&#xA;      // Desenhar cabeça do gato&#xD;&#xA;      ctx.fillStyle = &#39;darkgray&#39;;&#xD;&#xA;      ctx.fillRect(dino.x + 30, dino.y - 15, dino.largura - 30, 20);&#xD;&#xA;&#xD;&#xA;      // // Desenhar orelha do gato&#xD;&#xA;      // ctx.fillStyle = &#39;lightgray&#39;;&#xD;&#xA;      // ctx.beginPath();&#xD;&#xA;      // ctx.moveTo(dino.x + 30, dino.y - 15);&#xD;&#xA;      // ctx.lineTo(dino.x + 25, dino.y - 30);&#xD;&#xA;      // ctx.lineTo(dino.x + 35, dino.y - 30);&#xD;&#xA;      // ctx.closePath();&#xD;&#xA;      // ctx.fill();&#xD;&#xA;&#xD;&#xA;      // Desenhar olho do gato&#xD;&#xA;      // ctx.fillStyle = &#39;black&#39;;&#xD;&#xA;      // ctx.fillRect(dino.x + 35, dino.y - 5, 5, 5);&#xD;&#xA;&#xD;&#xA;      // Desenhar rabo do gato&#xD;&#xA;      ctx.fillStyle = &#39;gray&#39;;&#xD;&#xA;      ctx.fillRect(dino.x - 10, dino.y + 10, 10, 5);&#xD;&#xA;      &#xD;&#xA;      // Desenhar pernas do gato com animação de corrida&#xD;&#xA;      ctx.fillStyle = &#39;darkgray&#39;;&#xD;&#xA;      if (passo &lt; 5) {&#xD;&#xA;        // Perna da frente esticada, perna de trás encolhida&#xD;&#xA;        ctx.fillRect(dino.x + 10, dino.y + dino.altura - 10, 5, 10);&#xD;&#xA;        ctx.fillRect(dino.x + 35, dino.y + dino.altura - 5, 5, 5);&#xD;&#xA;      } else {&#xD;&#xA;        // Perna da frente encolhida, perna de trás esticada&#xD;&#xA;        ctx.fillRect(dino.x + 10, dino.y + dino.altura - 5, 5, 5);&#xD;&#xA;        ctx.fillRect(dino.x + 35, dino.y + dino.altura - 10, 5, 10);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // Função para desenhar obstáculos&#xD;&#xA;    function desenharObstaculos() {&#xD;&#xA;      for (let i = 0; i &lt; obstaculos.length; i++) {&#xD;&#xA;        const obs = obstaculos[i];&#xD;&#xA;        ctx.fillStyle = obs.cor;&#xD;&#xA;        ctx.fillRect(obs.x, obs.y, obs.largura, obs.altura);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // Função para verificar colisão precisa&#xD;&#xA;    function verificarColisao(a, b) {&#xD;&#xA;      // Reduzir um pouco a área de colisão para ser mais justo&#xD;&#xA;      const margemColisao = 5;&#xD;&#xA;      return a.x + a.largura - margemColisao &gt; b.x + margemColisao &amp;&amp;&#xD;&#xA;             a.x + margemColisao &lt; b.x + b.largura - margemColisao &amp;&amp;&#xD;&#xA;             a.y + a.altura - margemColisao &gt; b.y + margemColisao &amp;&amp;&#xD;&#xA;             a.y + margemColisao &lt; b.y + b.altura - margemColisao;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // Função para criar novo obstáculo&#xD;&#xA;    function criarObstaculo() {&#xD;&#xA;      const tipoObstaculo = TIPOS_OBSTACULOS[Math.floor(Math.random() * TIPOS_OBSTACULOS.length)];&#xD;&#xA;      &#xD;&#xA;      obstaculos.push({&#xD;&#xA;        x: canvas.width,&#xD;&#xA;        y: tipoObstaculo.y,&#xD;&#xA;        largura: tipoObstaculo.largura,&#xD;&#xA;        altura: tipoObstaculo.altura,&#xD;&#xA;        cor: tipoObstaculo.cor&#xD;&#xA;      });&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // Função para fim de jogo&#xD;&#xA;    function fimDeJogo() {&#xD;&#xA;      gameOver = true;&#xD;&#xA;      // Tocar som de game over&#xD;&#xA;      somGameOver.play();&#xD;&#xA;      ctx.font = &#39;bold 36px Arial&#39;;&#xD;&#xA;      ctx.fillStyle = &#39;red&#39;;&#xD;&#xA;      ctx.textAlign = &#39;center&#39;;&#xD;&#xA;      ctx.fillText(&#39;Game Over!&#39;, canvas.width / 2, canvas.height / 2 - 20);&#xD;&#xA;      &#xD;&#xA;      ctx.font = &#39;24px Arial&#39;;&#xD;&#xA;      ctx.fillStyle = &#39;black&#39;;&#xD;&#xA;      ctx.fillText(&#39;Placar: &#39; + placar, canvas.width / 2, canvas.height / 2 + 20);&#xD;&#xA;      &#xD;&#xA;      ctx.font = &#39;18px Arial&#39;;&#xD;&#xA;      ctx.fillText(&#39;Pressione R para reiniciar&#39;, canvas.width / 2, canvas.height / 2 + 50);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // Função para atualizar o jogo&#xD;&#xA;    function atualizar() {&#xD;&#xA;      ctx.clearRect(0, 0, canvas.width, canvas.height);&#xD;&#xA;&#xD;&#xA;      // Se o jogo acabou, só mostrar tela de game over&#xD;&#xA;      if (gameOver) {&#xD;&#xA;        desenharCenario();&#xD;&#xA;        desenharDino();&#xD;&#xA;        desenharObstaculos();&#xD;&#xA;        fimDeJogo();&#xD;&#xA;        return;&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      // Atualizar dinossauro&#xD;&#xA;      if (!estaNoChao) {&#xD;&#xA;        dino.y += dino.velocidadeY;&#xD;&#xA;        dino.velocidadeY += gravidade;&#xD;&#xA;        if (dino.y &gt; 200) {&#xD;&#xA;          dino.y = 200;&#xD;&#xA;          estaNoChao = true;&#xD;&#xA;          dino.velocidadeY = 0;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      // Atualizar obstáculos&#xD;&#xA;      for (let i = 0; i &lt; obstaculos.length; i++) {&#xD;&#xA;        obstaculos[i].x -= velocidadeJogo;&#xD;&#xA;        if (obstaculos[i].x &lt; -obstaculos[i].largura) {&#xD;&#xA;          obstaculos.splice(i, 1);&#xD;&#xA;          placar++;&#xD;&#xA;          &#xD;&#xA;          // Tocar som ao marcar ponto&#xD;&#xA;          somPonto.play();&#xD;&#xA;&#xD;&#xA;          // Aumentar velocidade a cada 50 pontos&#xD;&#xA;          if (placar % 10 === 0) {&#xD;&#xA;            velocidadeJogo += 0.5;&#xD;&#xA;          }&#xD;&#xA;          i--;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      // Mover montanhas com efeito parallax&#xD;&#xA;      montanha1.x -= montanha1.velocidade;&#xD;&#xA;      montanha2.x -= montanha2.velocidade;&#xD;&#xA;&#xD;&#xA;      // Mover nuvens com efeito parallax&#xD;&#xA;      for (let i = 0; i &lt; nuvens.length; i++) {&#xD;&#xA;        nuvens[i].x -= nuvens[i].velocidade;&#xD;&#xA;        if (nuvens[i].x + nuvens[i].largura &lt; 0) {&#xD;&#xA;          nuvens[i].x = canvas.width;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      // Resetar posição das montanhas quando saem da tela&#xD;&#xA;      if (montanha1.x + 200 &lt; 0) {&#xD;&#xA;        montanha1.x = canvas.width;&#xD;&#xA;      }&#xD;&#xA;      if (montanha2.x + 300 &lt; 0) {&#xD;&#xA;        montanha2.x = canvas.width;&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      // Verificar colisões&#xD;&#xA;      for (let i = 0; i &lt; obstaculos.length; i++) {&#xD;&#xA;        if (verificarColisao(dino, obstaculos[i])) {&#xD;&#xA;          gameOver = true;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      // Desenhar elementos&#xD;&#xA;      desenharCenario();&#xD;&#xA;      desenharDino();&#xD;&#xA;      desenharObstaculos();&#xD;&#xA;&#xD;&#xA;      // Atualizar a animação das pernas&#xD;&#xA;      passo = (passo + 1) % 10;&#xD;&#xA;&#xD;&#xA;      // Adicionar obstáculos (chance aumenta com a pontuação)&#xD;&#xA;      const chanceObstaculo = 0.01 + (placar / 500); // Máximo de 0.05&#xD;&#xA;      if (Math.random() &lt; Math.min(chanceObstaculo, 0.05) &amp;&amp; obstaculos.length &lt; 3) {&#xD;&#xA;        // Verificar se o último obstáculo está longe o suficiente&#xD;&#xA;        const ultimoObstaculo = obstaculos[obstaculos.length - 1];&#xD;&#xA;        if (!ultimoObstaculo || canvas.width - ultimoObstaculo.x &gt; 300) {&#xD;&#xA;          criarObstaculo();&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      // Desenhar placar&#xD;&#xA;      ctx.font = &#39;24px Arial&#39;;&#xD;&#xA;      ctx.fillStyle = &#39;black&#39;;&#xD;&#xA;      ctx.textAlign = &#39;left&#39;;&#xD;&#xA;      ctx.fillText(&#39;Placar: &#39; + placar, 10, 30);&#xD;&#xA;&#xD;&#xA;      // Desenhar Hi-Score no canto superior direito&#xD;&#xA;      ctx.textAlign = &#39;right&#39;;&#xD;&#xA;      ctx.fillText(&#39;Hi-Score: &#39; + hiScore, canvas.width - 10, 30);&#xD;&#xA;      &#xD;&#xA;      // Desenhar velocímetro no canto inferior direito&#xD;&#xA;      desenharVelocimetro(velocidadeJogo, canvas.width - 60, canvas.height - 50, 50);&#xD;&#xA;&#xD;&#xA;      // Atualizar Hi-Score&#xD;&#xA;      if (placar &gt; hiScore) {&#xD;&#xA;        hiScore = placar;&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      requestAnimationFrame(atualizar);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    function desenharVelocimetro(velocidade, x, y, raio) {&#xD;&#xA;      // Desenhar fundo do velocímetro&#xD;&#xA;      ctx.beginPath();&#xD;&#xA;      ctx.arc(x, y, raio, Math.PI, 0, false);&#xD;&#xA;      ctx.fillStyle = &#39;#eee&#39;;&#xD;&#xA;      ctx.fill();&#xD;&#xA;      ctx.stroke();&#xD;&#xA;&#xD;&#xA;      // Desenhar ponteiro&#xD;&#xA;      const angulo = Math.PI + (velocidade / 20) * Math.PI; // Ajuste conforme necessário&#xD;&#xA;      const xPonteiro = x + Math.cos(angulo) * (raio - 10);&#xD;&#xA;      const yPonteiro = y + Math.sin(angulo) * (raio - 10);&#xD;&#xA;&#xD;&#xA;      ctx.beginPath();&#xD;&#xA;      ctx.moveTo(x, y);&#xD;&#xA;      ctx.lineTo(xPonteiro, yPonteiro);&#xD;&#xA;      ctx.strokeStyle = &#39;red&#39;;&#xD;&#xA;      ctx.lineWidth = 3;&#xD;&#xA;      ctx.stroke();&#xD;&#xA;      ctx.lineWidth = 1;&#xD;&#xA;&#xD;&#xA;      // Desenhar valor da velocidade&#xD;&#xA;      ctx.font = &#39;12px Arial&#39;;&#xD;&#xA;      ctx.fillStyle = &#39;black&#39;;&#xD;&#xA;      ctx.textAlign = &#39;center&#39;;&#xD;&#xA;      ctx.fillText(velocidade.toFixed(1) + &#39; km/h&#39;, x, y + raio / 2);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // Eventos de teclado&#xD;&#xA;    document.addEventListener(&#39;keydown&#39;, (e) =&gt; {&#xD;&#xA;      if (e.key === &#39; &#39; &amp;&amp; estaNoChao &amp;&amp; !gameOver) {&#xD;&#xA;        dino.velocidadeY = pulo;&#xD;&#xA;        estaNoChao = false;&#xD;&#xA;      }&#xD;&#xA;      if (e.key === &#39;r&#39; &amp;&amp; gameOver) {&#xD;&#xA;        // Reiniciar jogo&#xD;&#xA;        dino = { x: 50, y: 200, largura: 50, altura: 50, velocidadeY: 0 };&#xD;&#xA;        obstaculos = [];&#xD;&#xA;        placar = 0;&#xD;&#xA;        estaNoChao = true;&#xD;&#xA;        velocidadeJogo = 5;&#xD;&#xA;        gameOver = false;&#xD;&#xA;        atualizar();&#xD;&#xA;      }&#xD;&#xA;    });&#xD;&#xA;&#xD;&#xA;    // Iniciar o jogo&#xD;&#xA;    atualizar();&#xD;&#xA;  &lt;/script&gt;&#xD;&#xA;&lt;/body&gt;&#xD;&#xA;&lt;/html&gt;</description>
    </item>
  </channel>
</rss>
